# -*- coding: utf-8 -*-
"""PYTHON ASSIGNMENT PE.SKILLS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OuwPOYw9BkV1P7CcTKRa5NdOw-DMhbrV

**Ques01.** Explain the key features of Python that take it a popular choice for programming?

**Ans.**Python is widely popular for several key reasons:

Readability and Simplicity: Python's syntax is clean and easy to understand, making it accessible to beginners and allowing for rapid development.

Versatility: Python can be used for a wide range of applications, from web development and data analysis to artificial intelligence and scientific computing.

Extensive Libraries and Frameworks: Python boasts a rich ecosystem of libraries and frameworks (e.g., NumPy, Pandas, Django, Flask) that streamline and enhance development.

Strong Community Support: Python has a large and active community that contributes to its continuous improvement and provides extensive resources for learning and problem-solving.

Interpreted Language: Python is an interpreted language, which means code can be run as soon as it is written, without the need for compilation, aiding in quick testing and debugging.

Cross-Platform Compatibility: Python runs on various operating systems, including Windows, macOS, and Linux, making it a versatile choice for developers working in different environments.

Integration Capabilities: Python easily integrates with other languages and technologies, making it suitable for a wide range of projects and systems.

These features collectively contribute to Python's popularity among developers of all levels and across various fields.

**Ques02.** Describe the role of predefined keywords in Python and provide examples of how they are used in a program?

**Ans.**Predefined keywords in Python are reserved words that have special meanings and serve specific functions in the language's syntax. They cannot be used as identifiers (variable names, function names, etc.) because they are part of the language's core syntax. Keywords help define the structure and flow of a Python program.

Role of Predefined Keywords
Control Flow: Keywords like if, else, elif, for, while, break, continue, and pass manage the control flow of the program.
Data Types: Keywords like True, False, and None represent special constant values.
Function and Class Definitions: Keywords like def, return, lambda, class, and yield are used to define functions and classes.
Exception Handling: Keywords like try, except, finally, raise, and assert handle exceptions and errors.
Variable Scope and Importing: Keywords like global, nonlocal, import, from, as, and with manage scope and module imports.
Logical Operators: Keywords like and, or, and not are used as logical operators.
"""

#Control Flow
# Example of if, elif, and else
x = 10
if x > 0:
    print("x is positive")
elif x == 0:
    print("x is zero")
else:
    print("x is negative")

# Example of for loop
for i in range(5):
    print(i)

#Function and Class Definitions
# Example of defining a function with def and return
def add(a, b):
    return a + b

result = add(2, 3)
print(result)

# Example of defining a class
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print(f"{self.name} makes a sound")

dog = Animal("Dog")
dog.speak()

#Exception Handling
# Example of try, except, and finally
try:
    result = 10 / 0
except ZeroDivisionError:
    print("Cannot divide by zero")
finally:
    print("This will always execute")

#Variable Scope and Importing
# Example of global and nonlocal
x = 10

def outer():
    x = 5

    def inner():
        nonlocal x
        x = 15

    inner()
    print("Inner x:", x)

outer()
print("Global x:", x)

# Example of import and as
import math as m

print(m.sqrt(16))

#Logical Operators
# Example of and, or, and not
a = True
b = False

print(a and b)  # False
print(a or b)   # True
print(not a)    # False

"""**Ques03**. Compare and contrast mutable and immutable objects in Python with examples?

**Ans.** In Python, objects can be classified as either mutable or immutable. Understanding the differences between these two categories is crucial for efficient programming and debugging. Here's a detailed comparison:

Mutable Objects
Definition: Mutable objects can be changed after they are created. This means you can modify their content without changing their identity.

Examples: Lists, dictionaries, sets, and most user-defined objects.

Characteristics:

Changeable: The content or state of the object can be altered.
Dynamic: Mutable objects can grow or shrink in size.
Methods: They have methods that can modify the object in place.
"""

#Example
# List (mutable)
my_list = [1, 2, 3]
print("Original list:", my_list)

# Modifying the list
my_list.append(4)
print("Modified list:", my_list)

# Dictionary (mutable)
my_dict = {'a': 1, 'b': 2}
print("Original dictionary:", my_dict)

# Modifying the dictionary
my_dict['c'] = 3
print("Modified dictionary:", my_dict)

"""**Immutable Objects**

Definition: Immutable objects cannot be changed after they are created. Any modification results in the creation of a new object.

Examples: Strings, tuples, frozensets, and integers.

Characteristics:

Unchangeable: The content or state of the object cannot be altered.
Fixed Size: Immutable objects have a fixed size.
Methods: They return new objects instead of modifying the existing ones.
"""

#Example
# String (immutable)
my_string = "Hello"
print("Original string:", my_string)

# Modifying the string (creates a new string)
new_string = my_string + " World"
print("Modified string (new object):", new_string)

# Tuple (immutable)
my_tuple = (1, 2, 3)
print("Original tuple:", my_tuple)

# Modifying the tuple (creates a new tuple)
new_tuple = my_tuple + (4,)
print("Modified tuple (new object):", new_tuple)

"""**Key Differences**

Modification:

Mutable: Can be changed in place. Example: Lists can be extended with append().
Immutable: Cannot be changed in place. Any modification results in a new object. Example: Concatenating strings creates a new string.
Performance:

Mutable: Modifying an object in place can be more memory and time-efficient since no new object is created.
Immutable: Safer in concurrent programming since they cannot be modified, reducing the risk of unexpected behavior.
Usage:

Mutable: Suitable for collections of items that need to change. Example: Lists for dynamic arrays.
Immutable: Suitable for fixed data that should not change. Example: Tuples for fixed collections of items.
Practical Implications
Immutability for Safety: Immutable objects are inherently thread-safe and can be used as keys in dictionaries and elements in sets because their hash value does not change.

Mutability for Flexibility: Mutable objects allow in-place modifications, which can be more efficient and convenient when changes are frequent.

Conclusion
Understanding the distinction between mutable and immutable objects helps in writing efficient and error-free code. Use mutable objects when you need to modify data frequently, and immutable objects when you need stability and safety.

**Ques04.** Discuss the different types of operators in Python and provide examples of how they are used?

**Ans**. Python provides a rich set of operators that allow you to perform various operations on variables and values. These operators can be categorized into several types:

Arithmetic Operators

Comparison (Relational) Operators

Assignment Operators

Logical Operators

Bitwise Operators

Membership Operators

Identity Operators

1. Arithmetic Operators
These operators perform mathematical operations.

+ : Addition
- : Subtraction
* : Multiplication

/ : Division

% : Modulus

** : Exponentiation

// : Floor Division
"""

#Example
a = 10
b = 3

print(a + b)  # Addition: 13
print(a - b)  # Subtraction: 7
print(a * b)  # Multiplication: 30
print(a / b)  # Division: 3.3333...
print(a % b)  # Modulus: 1
print(a ** b) # Exponentiation: 1000
print(a // b) # Floor Division: 3

#Comparison (Relational) Operators
#These operators compare values and return a Boolean result.

#== : Equal to
#!= : Not equal to
#> : Greater than
#< : Less than
#>= : Greater than or equal to
#<= : Less than or equal to
#Example:

a = 10
b = 3

print(a == b)  # Equal to: False
print(a != b)  # Not equal to: True
print(a > b)   # Greater than: True
print(a < b)   # Less than: False
print(a >= b)  # Greater than or equal to: True
print(a <= b)  # Less than or equal to: False

#Assignment Operators
#These operators assign values to variables.

#= : Assignment
#+= : Add and assign
#-= : Subtract and assign
#*= : Multiply and assign
#/= : Divide and assign
#%= : Modulus and assign
#**= : Exponent and assign
#//= : Floor divide and assign

#Example:

a = 10
a += 3  # Equivalent to a = a + 3
print(a)  # 13

a -= 3  # Equivalent to a = a - 3
print(a)  # 10

a *= 3  # Equivalent to a = a * 3
print(a)  # 30

a /= 3  # Equivalent to a = a / 3
print(a)  # 10.0

a %= 3  # Equivalent to a = a % 3
print(a)  # 1.0

a **= 3  # Equivalent to a = a ** 3
print(a)  # 1.0

a //= 3  # Equivalent to a = a // 3
print(a)  # 0.0

#Logical Operators
#These operators perform logical operations and return Boolean values.

#and : Logical AND
#or : Logical OR
#not : Logical NOT
#Example:
a = True
b = False

print(a and b)  # Logical AND: False
print(a or b)   # Logical OR: True
print(not a)    # Logical NOT: False

#Bitwise Operators
#These operators perform bit-level operations on binary numbers.

#& : Bitwise AND
#| : Bitwise OR
#^ : Bitwise XOR
#~ : Bitwise NOT
#<< : Bitwise left shift
#>> : Bitwise right shift

#Example:
a = 10  # 1010 in binary
b = 4   # 0100 in binary

print(a & b)  # Bitwise AND: 0
print(a | b)  # Bitwise OR: 14 (1110 in binary)
print(a ^ b)  # Bitwise XOR: 14 (1110 in binary)
print(~a)     # Bitwise NOT: -11
print(a << 1) # Left shift: 20 (10100 in binary)
print(a >> 1) # Right shift: 5 (0101 in binary)

"""**Ques05**. Explain the concept of type casting in Python with examples?

**Ans.**Type casting in Python refers to the conversion of one data type into another. This is useful when you need to perform operations on variables that are of different types. Python provides several built-in functions for type casting, which include int(), float(), str(), list(), tuple(), set(), and more.

Examples of Type Casting
"""

#Integer to Float:
num = 10
print(type(num))  # Output: <class 'int'>

num_float = float(num)
print(num_float)  # Output: 10.0
print(type(num_float))  # Output: <class 'float'>

#Float to Integer:
num = 10.5
print(type(num))  # Output: <class 'float'>

num_int = int(num)
print(num_int)  # Output: 10
print(type(num_int))  # Output: <class 'int'>

#String to Integer:
num_str = "100"
print(type(num_str))  # Output: <class 'str'>

num_int = int(num_str)
print(num_int)  # Output: 100
print(type(num_int))  # Output: <class 'int'>

#String to Float:
num_str = "123.45"
print(type(num_str))  # Output: <class 'str'>

num_float = float(num_str)
print(num_float)  # Output: 123.45
print(type(num_float))  # Output: <class 'float'>

#Integer to String:
num = 200
print(type(num))  # Output: <class 'int'>

num_str = str(num)
print(num_str)  # Output: '200'
print(type(num_str))  # Output: <class 'str'>

#List to Tuple:
lst = [1, 2, 3]
print(type(lst))  # Output: <class 'list'>

tup = tuple(lst)
print(tup)  # Output: (1, 2, 3)
print(type(tup))  # Output: <class 'tuple'>

#Tuple to List:
tup = (4, 5, 6)
print(type(tup))  # Output: <class 'tuple'>

lst = list(tup)
print(lst)  # Output: [4, 5, 6]
print(type(lst))  # Output: <class 'list'>

#String to List:
str_val = "hello"
print(type(str_val))  # Output: <class 'str'>

lst = list(str_val)
print(lst)  # Output: ['h', 'e', 'l', 'l', 'o']
print(type(lst))  # Output: <class 'list'>

"""**Ques06**. How do conditional statements work in Python? Illustrate with examples?

**Ans**.Conditional statements in Python allow you to execute different blocks of code based on certain conditions. These statements use logical expressions to determine which block of code should run. The primary conditional statements in Python are if, elif, and else.

Basic Syntax

if Statement:

python
Copy code
if condition:
    # Code to execute if condition is true
if-else Statement:

python
Copy code
if condition:
    # Code to execute if condition is true
else:
    # Code to execute if condition is false
if-elif-else Statement:

python
Copy code
if condition1:
    # Code to execute if condition1 is true
elif condition2:
    # Code to execute if condition2 is true
else:
    # Code to execute if none of the above conditions are true
Examples
Simple if Statement:

python
Copy code
num = 10
if num > 5:
    print("The number is greater than 5.")
# Output: The number is greater than 5.
if-else Statement:

python
Copy code
num = 3
if num > 5:
    print("The number is greater than 5.")
else:
    print("The number is 5 or less.")
# Output: The number is 5 or less.
if-elif-else Statement:

python
Copy code
num = 7
if num > 10:
    print("The number is greater than 10.")
elif num == 10:
    print("The number is equal to 10.")
else:
    print("The number is less than 10.")
# Output: The number is less than 10.
Nested if Statements:

python
Copy code
num = 15
if num > 10:
    print("The number is greater than 10.")
    if num > 20:
        print("The number is also greater than 20.")
    else:
        print("The number is 20 or less.")
else:
    print("The number is 10 or less.")
# Output:
# The number is greater than 10.
# The number is 20 or less.
Using Logical Operators:

python
Copy code
num = 8
if num > 5 and num < 10:
    print("The number is between 5 and 10.")
else:
    print("The number is not between 5 and 10.")
# Output: The number is between 5 and 10.
Checking Multiple Conditions:

python
Copy code
weather = "sunny"
temperature = 30

if weather == "sunny" and temperature > 25:
    print("It's a great day for the beach!")
elif weather == "rainy":
    print("Better stay indoors.")
else:
    print("Weather is moderate, enjoy your day!")
# Output: It's a great day for the beach!
Important Points
The condition in an if statement is evaluated as a Boolean expression. If the condition is True, the code block under the if statement is executed.
The elif statement allows you to check multiple conditions sequentially. If the previous conditions are False, the elif condition is evaluated.
The else statement is optional and executes if none of the preceding conditions are True.
Indentation is crucial in Python and determines the block of code associated with the conditional statements. Each level of indentation must be consistent.
"""

#Examples
#Simple if Statement:
num = 10
if num > 5:
    print("The number is greater than 5.")

# Output: The number is greater than 5.
#if-else Statement:
num = 3
if num > 5:
    print("The number is greater than 5.")
else:
    print("The number is 5 or less.")

# Output: The number is 5 or less.
#if-elif-else Statement:
num = 7
if num > 10:
    print("The number is greater than 10.")
elif num == 10:
    print("The number is equal to 10.")
else:
    print("The number is less than 10.")

# Output: The number is less than 10.
#Nested if Statements:
num = 15
if num > 10:
    print("The number is greater than 10.")
    if num > 20:
        print("The number is also greater than 20.")
    else:
        print("The number is 20 or less.")
else:
    print("The number is 10 or less.")

# Output:
# The number is greater than 10.
# The number is 20 or less.
#Using Logical Operators:
num = 8
if num > 5 and num < 10:
    print("The number is between 5 and 10.")
else:
    print("The number is not between 5 and 10.")

# Output: The number is between 5 and 10.
#Checking Multiple Conditions:
weather = "sunny"
temperature = 30

if weather == "sunny" and temperature > 25:
    print("It's a great day for the beach!")
elif weather == "rainy":
    print("Better stay indoors.")
else:
    print("Weather is moderate, enjoy your day!")
# Output: It's a great day for the beach!

"""**Ques07**. Describe the different types of loops in Python and their use cases with examples?

**Ans.**Python provides two primary types of loops: for loops and while loops. Each has its own use cases and specific scenarios where it is more appropriate.

1. for Loop
The for loop is used for iterating over a sequence (such as a list, tuple, dictionary, set, or string). It is the best choice when you know in advance how many times you need to iterate.
"""

#Examples:
#Iterating Over a List:
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
    print(fruit)
# Output:
# apple
# banana
# cherry

#Iterating Over a String:
for char in "hello":
    print(char)
# Output:
# h
# e
# l
# l
# o

#Using range():

for i in range(5):
    print(i)
# Output:
# 0
# 1
# 2
# 3
# 4

#Iterating Over a Dictionary:
person = {"name": "John", "age": 30, "city": "New York"}
for key, value in person.items():
    print(key, value)
# Output:
# name John
# age 30
# city New York

"""**2. while Loop**

The while loop is used to execute a block of code as long as a condition is True. It is best used when the number of iterations is not known beforehand and depends on a condition.
"""

#Examples:
#Basic while Loop:
count = 0
while count < 5:
    print(count)
    count += 1
# Output:
# 0
# 1
# 2
# 3
# 4

#Using break Statement:
count = 0
while True:
    print(count)
    count += 1
    if count == 5:
        break
# Output:
# 0
# 1
# 2
# 3
# 4

#Using continue Statement:
count = 0
while count < 5:
    count += 1
    if count == 3:
        continue
    print(count)
# Output:
# 1
# 2
# 4
# 5

"""**Use Cases**
**for Loop Use Cases:**

Iterating over elements of a collection (list, tuple, dictionary, set, etc.).
Running a loop for a specific number of times using range().
When the size of the sequence is known or fixed.
while Loop Use Cases:

When the number of iterations is not known beforehand and depends on a condition.
For loops that need to continue until a certain condition is met.
Implementing loops that may have variable iteration lengths based on dynamic conditions.
Additional Loop Control Statements

"""

#break Statement:
#Terminates the loop prematurely when encountered.
for i in range(10):
    if i == 5:
        break
    print(i)
# Output:
# 0
# 1
# 2
# 3
# 4

#continue Statement:
#Skips the rest of the code inside the loop for the current iteration and moves to the next iteration.
for i in range(5):
    if i == 2:
        continue
    print(i)
# Output:
# 0
# 1
# 3
# 4

#else Clause with Loops:
#Executed when the loop is not terminated by a break statement.
for i in range(5):
    print(i)
else:
    print("Loop completed without break.")
# Output:
# 0
# 1
# 2
# 3
# 4
# Loop completed without break.

"""**COMPLETED **"""